Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'as yet unclassified' stamp: 'my 2/22/2024 11:22'!testMethod: aString                                 | tempVar |(aString isKindOf: String) ifFalse:[ AssertionFailure signal: 'Type mismatch!! Argument 1 should be String'].                                tempVar := aString, test. ^tempVar.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: ''!!MyObject class methodsFor: 'part1' stamp: 'my 2/22/2024 11:00'!compile: aSourceCode where: anOrderedCollection| funcName funcVars funcImpl injectChecks line1Indx line2Indx newMethod arrayOfFuncArgs|"first, we need to break down a source code to parts"line1Indx := aSourceCode indexOf: ($|) startingAt: 1.line2Indx := aSourceCode indexOf: ($|) startingAt: (line1Indx+1).funcName:= aSourceCode copyFrom: 1 to:(line1Indx-1). "some_declaration:argA.....\n)"funcVars:= aSourceCode copyFrom: (line1Indx) to: (line2Indx+1)."| var1...... |\n)"funcImpl:= aSourceCode copyFrom: (line2Indx+2) to: (aSourceCode size).arrayOfFuncArgs := (funcName findTokens: ':') collect: [:each |    | words firstWord |    words := each subStrings: ' '.    firstWord := words isEmpty ifTrue: [nil] ifFalse: [words first].    firstWord].arrayOfFuncArgs select: [:each | each notNil].arrayOfFuncArgs:= arrayOfFuncArgs allButFirst."then we need to check if the num of args is the same as in anOrderCollection. if not- throw exc."((arrayOfFuncArgs size)=(anOrderedCollection size))ifFalse:[	AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'	]."now we need to inject the argument type check"injectChecks:=String new.arrayOfFuncArgs withIndexDo: [:argName :index |        | argType |        argType := anOrderedCollection at: index.        argType ifNotNil: [            injectChecks := injectChecks,'(', argName, ' isKindOf: ', ((argType name) copyWithout: $#),')',									 ' ifFalse:[ AssertionFailure signal: ''Type mismatch!! Argument ', 												index printString, ' should be ', ((argType name) 																				copyWithout: $#),'''].' , 																				String cr.        					].    				].		"now we will add all to a regular string of the implementation"newMethod:=funcName,funcVars, injectChecks,funcImpl."now we will call Compile- ^ self compile injectedMethod"^ self compile: newMethod! !TestCase subclass: #MyObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObjectTest methodsFor: 'as yet unclassified' stamp: 'my 2/22/2024 10:42'!testCompileMethodWithCorrectTypes    "Test the method compiles and executes correctly with correct argument types."    MyObject compile: 'testMethod: aNumber                                | tempVar |                                tempVar := aNumber + 1. ^tempVar.'                where: #(Number).        self assert: (MyObject new testMethod: 1) equals: 2.! !!MyObjectTest methodsFor: 'as yet unclassified' stamp: 'my 2/22/2024 10:10'!testCompileMethodWithIncorrectArgumentCount    "Test the method compilation fails due to incorrect number of constraints."    self should: [MyObject compile: 'testMethod: aNumber anotherArg: anotherNumber                                                 | tempVar |                                                tempVar := aNumber + anotherNumber. ^tempVar.'                                where: #(Number)] raise: AssertionFailure.! !!MyObjectTest methodsFor: 'as yet unclassified' stamp: 'my 2/22/2024 10:50'!testTypeCheckFailsAtRuntime    "Test that the method raises an exception if an argument of the wrong type is passed."    MyObject compile: 'testMethod: aString                                 | tempVar |                                tempVar := aString, ','test','. ^tempVar.'                where: #(String).        self should: [MyObject new testMethod: 123] raise: AssertionFailure.! !