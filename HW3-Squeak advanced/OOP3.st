Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'helpers' stamp: 'my 3/6/2024 12:53'!allMethodsUnderstoodByClass: aClass    "Return a Set of all methods that aClass can understand, including those inherited from its superclass(es)."    | methodSet currentClass |    methodSet := Set new.    currentClass := aClass.        [currentClass notNil] whileTrue: [        methodSet addAll: currentClass methodDict keys.        currentClass := currentClass superclass.    ].        ^methodSet! !!MyObject class methodsFor: 'helpers' stamp: 'my 3/6/2024 12:30'!allSubclassesOf: aClass| directSubclasses allSubclasses |    directSubclasses := aClass subclasses.    allSubclasses := Set withAll: directSubclasses.        directSubclasses do: [:eachSubclass |        allSubclasses addAll: (self allSubclassesOf: eachSubclass)].            ^allSubclasses! !!MyObject class methodsFor: 'helpers' stamp: 'my 3/3/2024 18:48'!getAllDefinedSelectors^(self selectors)! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 16:19'!ambiguities|totBehavior tempMethods totalMethods ambMethods|"totBehavior-  a set of interfaces we behave like them.tempMethods- all the selectors from a single interface.totalMethods - tzover all the selctors we have iterated over.ambMethos- all the methods that are defined in different places, the result we will return"totBehavior:= self behavesLike.totalMethods:=Set new.ambMethods:= Set new.totBehavior do:[ :interface |		tempMethods:= interface getAllDefinedSelectors.	tempMethods do:[ :aSelector |		(totalMethods includes: aSelector)		ifTrue:[			ambMethods add: aSelector.			].		totalMethods add: aSelector.		]	].^((SortedCollection new) addAll:ambMethods; yourself)! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 14:57'!behavesLike| totBehavior currentSuperclass|totBehavior:= Set new.currentSuperclass:=self superclass.totBehavior addAll: behavesLike."we add all the behavior of the super-Classes"[currentSuperclass ~= MyObject] "need to check who understands BehaveLike" whileTrue:[	totBehavior addAll:(currentSuperclass behavesLike).	currentSuperclass:= currentSuperclass superclass.	]."now we need to add all the behaviors of all the interfaces in the variable 'behavesLike' "behavesLike do:[:interface|			(interface~=self)			ifTrue:[				totBehavior addAll: (interface behavesLike).				].			].(isInterface=true)ifTrue:[	totBehavior add: self.	].^totBehavior.! !!MyObject class methodsFor: 'part2' stamp: 'my 3/3/2024 18:14'!compile: aCode|indexCR indexLF |(self isInterface = true)ifTrue:[	indexCR := aCode indexOf: Character cr.	indexLF := aCode indexOf: Character lf.	 (indexCR > 0 or: [indexLF > 0])	ifTrue:[		AssertionFailure signal:'Interfaces are not allowed to have methods that define behavior!!'		].	]."Choose the smaller, non-zero index if both are present; otherwise, choose whichever is non-zero.""indexNewLine := (indexCR > 0 and: [indexLF > 0])    ifTrue: [indexCR min: indexLF]    ifFalse: [	(indexCR > 0 ifTrue: [indexCR] ifFalse: [indexLF])].""depends on the piazza answer"^self compile: aCode notifying: nil! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 13:17'!isImplemented| interfaceBehavior interfaceMethods allSubClasses totSize|"check for errors first"(self isInterface=false)ifTrue:[	AssertionFailure signal: ((self name) copyWithout: $#),' is not an interface!!'.	]."second- we will get all the methods that need to be implemented"interfaceBehavior:=self behavesLike.interfaceMethods:=Set new. interfaceBehavior do:[:interface|	interfaceMethods addAll:(interface getAllDefinedSelectors)	].totSize:= interfaceMethods size."we want to get all the subclasses of MyObject to iterate over."allSubClasses:=self allSubclassesOf: MyObject."for every class- check if it implements the given interface.reminder: a class implements an interface if:1.it behaves like it.2. all methods of the interface are implemented in the class (or it's suerclasses)."allSubClasses do:[ :aClass|	"we will check a subclass only if it is not an interface, because interfaces are also subclasses of MyObject "	(aClass isInterface = false)	ifTrue:[		|tempAllMethods tempBehavior tempCount|		"we will check if the class behaves like the current interface- 1st condition"		tempBehavior:=aClass behavesLike.		(tempBehavior includes: self)		ifTrue:[			"now we will check if all the interface methods are implemented in the class- 2nd condition"			tempCount:=0.			tempAllMethods:= self allMethodsUnderstoodByClass: aClass.			interfaceMethods do:[:aMethod|				(tempAllMethods includes: aMethod)				ifTrue:[					tempCount:= tempCount+1.					]				].			(tempCount = totSize)			ifTrue:[				^true				].			]		]	].^false! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 14:57'!isInterface ^isInterface! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 14:57'!new	(isInterface=true)	ifTrue:[		AssertionFailure signal:'Interfaces can not be instantiated!!'.		].	^ self basicNew initialize! !!MyObject class methodsFor: 'part2' stamp: 'my 2/26/2024 19:44'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName^self subclass: aSubclassName isInterface: (false) behavesLike:(Array new) instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category:aCategoryName! !!MyObject class methodsFor: 'part2' stamp: 'my 3/6/2024 15:43'!subclass: aSubclassName isInterface: isInterfaceVar behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category:aCategoryName| subClass | "exception #2.1"( isInterfaceVar=true and:[self ~= MyObject])ifTrue:[	AssertionFailure signal:'Interfaces must derive from MyObject!!'.	]."exception #2.2"( isInterfaceVar=true and:[ instVarNames ~= ''])ifTrue:[	AssertionFailure signal:'Interfaces can not have state!!'.	]."exception #2.3"( isInterfaceVar=false and:[isInterface = true ])ifTrue:[	AssertionFailure signal:'Classes can not derive from an interface!!'.	]."exception #2.4"aCollection do:[:element |	((element isInterface)=false)	ifTrue:[			AssertionFailure signal:'Can not behave like a non-interface!!'.		]	]."now we are ok, create a subclass""This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver). "	subClass:=(ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: (classVarNames)		poolDictionaries: poolDictionaries		category: aCategoryName.		((subClass) instVarNamed:'isInterface' put: isInterfaceVar ).		((subClass) instVarNamed:'behavesLike' put: aCollection ).		"subClass classPool at: 'IsInterface' put: isInterfaceVar.		subClass classPool at:'BehavesLike' put: aCollection."			^subClass! !!MyObject class methodsFor: 'part1' stamp: 'my 3/6/2024 17:39'!compile: aSourceCode where: anOrderedCollection| funcName funcVars funcImpl injectChecks line1Indx line2Indx newMethod arrayOfFuncArgs hasVars|"first, we need to break down a source code to parts"line1Indx := aSourceCode indexOf: ($|) startingAt: 1."if there are no local vars- break down in a different way"(line1Indx = 0)ifFalse:[	line2Indx := aSourceCode indexOf: ($|) startingAt: (line1Indx+1).	funcVars:= aSourceCode copyFrom: (line1Indx) to: (line2Indx+1)."| var1...... |\n)"	funcImpl:= aSourceCode copyFrom: (line2Indx+2) to: (aSourceCode size).	funcName:= aSourceCode copyFrom: 1 to:(line1Indx-1). "some_declaration:argA.....\n)"	hasVars:=true	]ifTrue:[	line1Indx := aSourceCode indexOf: (Character cr) startingAt: 1.	(line1Indx=0)	ifTrue:[		line1Indx := aSourceCode indexOf: (Character lf) startingAt: 1.		].	(line1Indx=0)	ifTrue:[		funcName:=aSourceCode.		funcImpl:=''.		funcVars:=''.		]	ifFalse:[		funcImpl:= aSourceCode copyFrom: (line1Indx+1) to: (aSourceCode size).		funcVars:=''.		funcName:= aSourceCode copyFrom: 1 to:(line1Indx-1). "some_declaration:argA.....\n)"		].	hasVars=false	].arrayOfFuncArgs := (funcName findTokens: ':') collect: [:each |    | words firstWord |    words := each subStrings: ' '.    firstWord := words isEmpty ifTrue: [nil] ifFalse: [words first].    firstWord].arrayOfFuncArgs select: [:each | each notNil].arrayOfFuncArgs:= arrayOfFuncArgs allButFirst.	"then we need to check if the num of args is the same as in anOrderCollection. if not- throw exc."((arrayOfFuncArgs size)=(anOrderedCollection size))ifFalse:[	AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'	]."now we need to inject the argument type check"injectChecks:=String new.arrayOfFuncArgs withIndexDo: [:argName :index |        | argType |        argType := anOrderedCollection at: index.        argType ifNotNil: [            injectChecks := injectChecks,'(', argName, ' isKindOf: ', ((argType name) copyWithout: $#),')',									 ' ifFalse:[ AssertionFailure signal: ''Type mismatch!! Argument ', 												index printString, ' should be ', ((argType name) 																				copyWithout: $#),'''].' , 																				String cr.        					].    				].		"now we will add all to a regular string of the implementation"newMethod:=funcName,funcVars, injectChecks,funcImpl."Transcript show: newMethod.""now we will call Compile- ^ self compile injectedMethod"^ self compile: newMethod! !