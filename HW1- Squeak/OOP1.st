Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'getting' stamp: 'marina 1/25/2024 18:00'!coef	^coef! !!Monom methodsFor: 'getting' stamp: 'marina 1/25/2024 18:00'!exp	^exp! !!Monom methodsFor: 'actions' stamp: 'marina 1/26/2024 21:49'!derivative	| monomDeriative |	monomDeriative := Monom new.	((exp = 0) or: [coef = 0])	ifTrue: [		^monomDeriative	]	ifFalse: [		monomDeriative coef: ((self coef)  * (self exp)).		monomDeriative exp: ((self exp) - 1).		^monomDeriative	]! !!Monom methodsFor: 'setting' stamp: 'marina 1/25/2024 18:01'!coef: anInteger	(anInteger isKindOf: Integer)	ifTrue: [		coef := anInteger.		^self	]	ifFalse: [		self error: 'invalid input'	]! !!Monom methodsFor: 'setting' stamp: 'marina 1/25/2024 18:01'!exp: anInteger	((anInteger isKindOf: Integer) and: [anInteger>=0])	ifTrue: [		exp := anInteger.		^self	]	ifFalse: [		self error: 'invalid input'	]! !!Monom methodsFor: 'initialize-release' stamp: 'marina 1/25/2024 17:57'!initialize	exp := 0.	coef := 0.	^self! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'getting' stamp: 'marina 1/29/2024 15:58'!block	^block! !!PolyStream methodsFor: 'calculative' stamp: 'Koren 1/28/2024 20:25'!substiture: anInteger	|operation|	(anInteger isKindOf: Integer)	ifTrue: [		anInteger=0		ifTrue: [			self error: 'invalid input'.			] 		ifFalse: [			operation := Array new: 2.			operation at: 1 put: anInteger ; at: 2 put: anInteger.			block value: operation.			]		]	ifFalse: [		self error: 'invalid input'.		]! !!PolyStream methodsFor: 'initialize-release' stamp: 'marina 1/29/2024 15:59'!initialize	block := [:evalValue :filters | 0].! !!PolyStream methodsFor: 'actions' stamp: 'marina 1/29/2024 16:17'!add: aPolyStream	(aPolyStream isKindOf: PolyStream) 	ifTrue:[		|currentState aPolyBlock|		currentState:= block.		aPolyBlock := aPolyStream block.		block := [:evalValue :filters | (currentState value: evalValue value: filters) + (aPolyBlock value: evalValue value: filters)].		]	ifFalse: [		self error: 'invalid input'.		].	! !!PolyStream methodsFor: 'actions' stamp: 'marina 1/29/2024 16:47'!addCoef: coef withExp: exp	((coef isKindOf: Integer) and: [exp isKindOf: Integer])	ifTrue:[		(exp <0)		ifTrue: [			self error: 'invalid input'.			]		ifFalse: [			|currentState|			currentState:= block.			block := [:evalValue :filters |				|tempResult| 				tempResult := currentState value: evalValue value: filters.				(filters includes: exp)				ifFalse: [					coef * (evalValue raisedTo: exp) + tempResult. 					]				].			].		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'marina 1/29/2024 16:48'!eval: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		|emptyFilter|		emptyFilter:= Set new.		^ block value: anInteger value: emptyFilter.		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'Koren 1/31/2024 20:25'!filter: aSet	| currentState tempASet |	tempASet := aSet copy.	currentState := block.	block := [:evalValue :filters |		currentState value: evalValue value: (filters union: tempASet).	].! !!PolyStream methodsFor: 'actions' stamp: 'my 2/3/2024 00:49'!multiplyBy: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		|currentState|		currentState:= block.		block := [:evalValue :filters | (anInteger * (currentState value: evalValue value: filters))].		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'marina 1/29/2024 16:50'!substitute: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		(anInteger = 0)		ifTrue: [			self error: 'invalid input'.			]				ifFalse: [			|currentState|			currentState:= block.			block := [:evalValue :filters | currentState value:(evalValue*anInteger) value: filters].			]		]	ifFalse: [		self error: 'invalid input'.		].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'calculative' stamp: 'my 2/3/2024 00:40'!addMonom: aMonom	(aMonom isKindOf: Monom) "CHECK IF aMonom IS MONOM OBJECT"	ifTrue: [		|newMon tempCoef |		(aMonom coef = 0) ifTrue:[^self].  "IF WE RECIEVED 0 AS A POLYNOM- DO NOTHING"				newMon := monoms at: (aMonom exp) ifAbsent: [nil].		(newMon isNil)		ifTrue: [			newMon := Monom new.			newMon coef: (aMonom coef).			] "IF THERE IS NO OTHER MONOM WITH THE SAME EXPONENT-WE CREATE A NEW MONOM"		ifFalse: [			tempCoef := (newMon coef) + (aMonom coef).			newMon coef: tempCoef.			monoms removeKey: (aMonom exp).			]. "IF WE FOUND A MONOM WITH THE SAME EXPONENT- WE JUST MODIFY THAT MONOM"				newMon exp: (aMonom exp).				(newMon coef = 0)		ifFalse:[			monoms at: (aMonom exp) put: newMon.			].		^self		]		ifFalse: [		self error: 'invalid input'.		]! !!Polynom methodsFor: 'calculative' stamp: 'Koren 1/28/2024 18:17'!derivative    | resultPolynom |    resultPolynom := Polynom new.    monoms do: [ :monom |        resultPolynom addMonom: (monom derivative).    ].    ^ resultPolynom.! !!Polynom methodsFor: 'calculative' stamp: 'marina 1/26/2024 19:09'!eval: anInteger	|result|	result := 0.		(anInteger isKindOf: Integer)	ifTrue: [		monoms do:[ :value |			| temp adden |				adden := result.			(value exp=0) "IF THE EXPONENT IS ZERO, WE WANT TO AVOID 0^0"			ifTrue:[temp := value coef.]			ifFalse:[temp := (value coef)* (anInteger raisedTo: (value exp)).].						result := temp + adden.			]. 				^result		]	ifFalse: [		self error: 'invalid input'.		]! !!Polynom methodsFor: 'calculative' stamp: 'my 2/3/2024 00:45'!multiplyByMonom: aMonom	| resPolynom |	(aMonom isKindOf: Monom)	ifTrue: [		resPolynom := Polynom new.		monoms do:[ :value |			| tempExp tempCoef tempMonom |					tempExp := (value exp) + (aMonom exp).			tempCoef := (value coef) * (aMonom coef).						tempMonom := Monom new.			tempMonom exp: tempExp; coef: tempCoef.			resPolynom addMonom: tempMonom.			]. "CALCULATE THE RESULT POLYNOM: MULTIPLY EACH MONOM IT THE POLYNOM BY THE GIVEN MONOM "		monoms removeAll.		(aMonom coef = 0)		ifFalse: [				monoms addAll: (resPolynom monoms).				"UPDATE THE CURRENT POLYNOM TO THE RESULT IF IT ISNT THE ZERO MONOM"			].		^self		]	ifFalse: [		self error: 'invalid input'.		]	! !!Polynom methodsFor: 'informative' stamp: 'my 2/3/2024 00:33'!add: aPolynom    | resultPolynom tempPoly|    (aPolynom isKindOf: Polynom)        ifTrue: [            resultPolynom := Polynom new.		tempPoly:= Polynom new.				(aPolynom monoms) do: [:value| 			|tempMonom|			tempMonom:= Monom new.			tempMonom exp: (value exp); coef: (value coef).			tempPoly addMonom: tempMonom.			].		                        monoms keysAndValuesDo: [ :exp :aMonom |                resultPolynom addMonom: aMonom.            ].                        (tempPoly monoms) keysAndValuesDo: [ :exp :aMonom |                resultPolynom addMonom: aMonom.            ].            ^ resultPolynom.        ]        ifFalse: [            self error: 'Invalid input.'        ].! !!Polynom methodsFor: 'informative' stamp: 'my 2/3/2024 00:47'!asDictionary    | resultDict |    resultDict := Dictionary new.    monoms do: [ :monom |        monom coef = 0            ifTrue: [ "Skip monom with coef = 0" ]            ifFalse: [ resultDict at: (monom exp) put: (monom coef) ].    ].    ^ resultDict.! !!Polynom methodsFor: 'informative' stamp: 'marina 1/26/2024 17:27'!monoms	^monoms! !!Polynom methodsFor: 'initialize-release' stamp: 'my 2/3/2024 00:42'!initialize	monoms := Dictionary new.	^self! !