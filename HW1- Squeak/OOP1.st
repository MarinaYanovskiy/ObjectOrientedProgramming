Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'getting' stamp: 'marina 1/25/2024 18:00'!coef	^coef! !!Monom methodsFor: 'getting' stamp: 'marina 1/25/2024 18:00'!exp	^exp! !!Monom methodsFor: 'actions' stamp: 'marina 1/26/2024 21:49'!derivative	| monomDeriative |	monomDeriative := Monom new.	((exp = 0) or: [coef = 0])	ifTrue: [		^monomDeriative	]	ifFalse: [		monomDeriative coef: ((self coef)  * (self exp)).		monomDeriative exp: ((self exp) - 1).		^monomDeriative	]! !!Monom methodsFor: 'setting' stamp: 'marina 1/25/2024 18:01'!coef: anInteger	(anInteger isKindOf: Integer)	ifTrue: [		coef := anInteger.		^self	]	ifFalse: [		self error: 'invalid input'	]! !!Monom methodsFor: 'setting' stamp: 'my 2/7/2024 15:01'!exp: anInteger	((anInteger isKindOf: Integer))	ifTrue: [		(anInteger>=0)		ifTrue:[			exp := anInteger.			^self			]		ifFalse:[			self error: 'invalid input'			]	]	ifFalse: [		self error: 'invalid input'	]! !!Monom methodsFor: 'initialize-release' stamp: 'marina 1/25/2024 17:57'!initialize	exp := 0.	coef := 0.	^self! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'getting' stamp: 'marina 1/29/2024 15:58'!block	^block! !!PolyStream methodsFor: 'initialize-release' stamp: 'my 2/4/2024 19:45'!initialize	block := [:evalValue :filters | 0 ].	"	THIS BLOCK RETURNS AN INTEGER WHICH IS THE RESULT OF x=evalValue IN THE POLYNOM.	PARAMETER evalValue: REPRESENTS THE x TO CALCULATE.	PARAMETER filters: ALL THE EXPONENTS THAT NEED TO BE FILTERED.	"! !!PolyStream methodsFor: 'actions' stamp: 'my 2/6/2024 23:03'!add: aPolyStream	(aPolyStream isKindOf: PolyStream) 	ifTrue:[		|currentState aPolyBlock|		currentState:= block.		aPolyBlock := aPolyStream block.		block := [:evalValue :filters | (currentState value: evalValue value: filters) + (aPolyBlock value: evalValue value: filters)].		^self		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'my 2/7/2024 14:47'!addCoef: coef withExp: exp	((coef isKindOf: Integer) and: (exp isKindOf: Integer))	ifTrue:[			|currentState calcResult|			(exp >= 0) 			ifFalse:[				self error: 'invalid input'.				].			currentState:= block.			block := [:evalValue :filters |						(filters includes: exp) "IF THE EXPONENT WILL BE FILTERED- DON'T ADD IT TO THE RESULT"						ifTrue: [							calcResult := (currentState value: evalValue value: filters).							]						ifFalse: [							calcResult := (currentState value: evalValue value: filters) + (coef * (evalValue raisedTo: exp)) .							].						calcResult.						].		^self		]				ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'my 2/4/2024 19:42'!eval: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		|emptyFilter|		emptyFilter:= Set new.		^ block value: anInteger value: emptyFilter. "NOW THE BLOCK WILL RUN"		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'my 2/6/2024 23:18'!filter: aSet	| currentState tempASet |	tempASet := aSet copy.	"WE WANT A COPY OF aSet SO THAT FUTURE CHANGES WON'T EFFECT THE POLYNOM"	currentState := block.	block := [:evalValue :filters |		tempASet addAll: filters.		currentState value: evalValue value: tempASet			].	^self! !!PolyStream methodsFor: 'actions' stamp: 'my 2/6/2024 22:54'!multiplyBy: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		|currentState|		currentState:= block.		block := [:evalValue :filters | 			  anInteger * (currentState value: evalValue value: filters)			].		^self		]	ifFalse: [		self error: 'invalid input'.		].! !!PolyStream methodsFor: 'actions' stamp: 'my 2/6/2024 22:55'!substitute: anInteger	(anInteger isKindOf: Integer)	ifTrue:[		(anInteger = 0)		ifTrue: [			self error: 'invalid input'.			]				ifFalse: [			|currentState|			currentState:= block.			block := [:evalValue :filters | currentState value:(evalValue*anInteger) value: filters].			^self			]		]	ifFalse: [		self error: 'invalid input'.		].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'calculative' stamp: 'my 2/3/2024 00:40'!addMonom: aMonom	(aMonom isKindOf: Monom) "CHECK IF aMonom IS MONOM OBJECT"	ifTrue: [		|newMon tempCoef |		(aMonom coef = 0) ifTrue:[^self].  "IF WE RECIEVED 0 AS A POLYNOM- DO NOTHING"				newMon := monoms at: (aMonom exp) ifAbsent: [nil].		(newMon isNil)		ifTrue: [			newMon := Monom new.			newMon coef: (aMonom coef).			] "IF THERE IS NO OTHER MONOM WITH THE SAME EXPONENT-WE CREATE A NEW MONOM"		ifFalse: [			tempCoef := (newMon coef) + (aMonom coef).			newMon coef: tempCoef.			monoms removeKey: (aMonom exp).			]. "IF WE FOUND A MONOM WITH THE SAME EXPONENT- WE JUST MODIFY THAT MONOM"				newMon exp: (aMonom exp).				(newMon coef = 0)		ifFalse:[			monoms at: (aMonom exp) put: newMon.			].		^self		]		ifFalse: [		self error: 'invalid input'.		]! !!Polynom methodsFor: 'calculative' stamp: 'Koren 1/28/2024 18:17'!derivative    | resultPolynom |    resultPolynom := Polynom new.    monoms do: [ :monom |        resultPolynom addMonom: (monom derivative).    ].    ^ resultPolynom.! !!Polynom methodsFor: 'calculative' stamp: 'marina 1/26/2024 19:09'!eval: anInteger	|result|	result := 0.		(anInteger isKindOf: Integer)	ifTrue: [		monoms do:[ :value |			| temp adden |				adden := result.			(value exp=0) "IF THE EXPONENT IS ZERO, WE WANT TO AVOID 0^0"			ifTrue:[temp := value coef.]			ifFalse:[temp := (value coef)* (anInteger raisedTo: (value exp)).].						result := temp + adden.			]. 				^result		]	ifFalse: [		self error: 'invalid input'.		]! !!Polynom methodsFor: 'calculative' stamp: 'my 2/3/2024 00:45'!multiplyByMonom: aMonom	| resPolynom |	(aMonom isKindOf: Monom)	ifTrue: [		resPolynom := Polynom new.		monoms do:[ :value |			| tempExp tempCoef tempMonom |					tempExp := (value exp) + (aMonom exp).			tempCoef := (value coef) * (aMonom coef).						tempMonom := Monom new.			tempMonom exp: tempExp; coef: tempCoef.			resPolynom addMonom: tempMonom.			]. "CALCULATE THE RESULT POLYNOM: MULTIPLY EACH MONOM IT THE POLYNOM BY THE GIVEN MONOM "		monoms removeAll.		(aMonom coef = 0)		ifFalse: [				monoms addAll: (resPolynom monoms).				"UPDATE THE CURRENT POLYNOM TO THE RESULT IF IT ISNT THE ZERO MONOM"			].		^self		]	ifFalse: [		self error: 'invalid input'.		]	! !!Polynom methodsFor: 'informative' stamp: 'my 2/4/2024 19:48'!add: aPolynom    | resultPolynom tempPoly|    (aPolynom isKindOf: Polynom)        ifTrue: [            resultPolynom := Polynom new.		tempPoly:= Polynom new.				(aPolynom monoms) do: [:value| 			|tempMonom|			tempMonom:= Monom new.			tempMonom exp: (value exp); coef: (value coef).			tempPoly addMonom: tempMonom.			].		"WE WANT TO COPY aPolynom SO THAT FUTURE CHANGES WON'T EFFECT THE RESULT"		                        monoms keysAndValuesDo: [ :exp :aMonom |                resultPolynom addMonom: aMonom.            ]. "ADD ALL THE CURRENT POLYNOM TO THE RESULT"                        (tempPoly monoms) keysAndValuesDo: [ :exp :aMonom |                resultPolynom addMonom: aMonom.            ]. "ADD THE GIVEN POLYNOM TO THE RESULT- THIS WILL ADD IT TO THE CURRENT POLYNOM."            ^ resultPolynom.        ]        ifFalse: [            self error: 'Invalid input.'        ].! !!Polynom methodsFor: 'informative' stamp: 'my 2/3/2024 00:47'!asDictionary    | resultDict |    resultDict := Dictionary new.    monoms do: [ :monom |        monom coef = 0            ifTrue: [ "Skip monom with coef = 0" ]            ifFalse: [ resultDict at: (monom exp) put: (monom coef) ].    ].    ^ resultDict.! !!Polynom methodsFor: 'informative' stamp: 'marina 1/26/2024 17:27'!monoms	^monoms! !!Polynom methodsFor: 'initialize-release' stamp: 'my 2/3/2024 00:42'!initialize	monoms := Dictionary new.	^self! !